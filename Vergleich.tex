\section{Vergleich mit anderen Logiken}
\label{ChapVerwandt}

Da nun die Logik $\PCTL$ bekannt ist sollen einige alternative Ansätze bzw. Logiken diskutiert werden, die entweder zeitliche Aspekte oder Wahrscheinlichkeiten hinzufügen.
Dafür sollen zwei Logiken genauer betrachtet werden.
Eine erweitert $\CTL$ durch ein komplexes System welches reelle Zeitwerte erlaubt und so sehr viel mehr über Zeit aussagen kann als $\PCTL$.
Die andere Logik stellt eine Erweiterung durch Wahrscheinlichkeiten dar.
Genauer wird eine Erweiterung des modalen $\mu$-Kalküls betrachtet, welche es ermöglicht, ähnlich wie in $\PCTL$ auszusagen, dass eine Formel für mindestens bzw. mehr als $p\%$ der Fälle gilt.

\subsection{Timed Computation Tree Logic}

In diesem Kapitel wird die in \cite{alur1990model} definierte Logik \textit{Timed Computation Tree Logic} ($\PCTL$) besprochen. Dafür werden die dazugehörigen Strukturen, ihre Syntax sowie ihre Semantik erörtert und durch Beispiele dargestellt.

Die Logik $\TCTL$ stellt, ähnlich wie $\PCTL$, eine Möglichkeit zur Verfügung, um zeitliche Zusammenhänge auszudrücken.
Während dies in $\PCTL$ aber nur mit diskreten Werten möglich ist, verwendet $\TCTL$ reelle Werte, wodurch sich Systeme potentiell besser beschreiben lassen.
Da dies aber offensichtlicher weise komplexer, als bloß bei jeder verwendeten Transition einen Zähler zu erhöhen, wird eine neue Struktur benötigt, welche Systeme modellieren soll und über welchen $\TCTL$-Formeln ausgewertet werden.
Dafür definieren wir eine feste Menge $\mathcal{N}$, welche uns Werte für zeitliche Vergleiche in Formeln gibt.
Der Einfachheit halber definieren wir hier $\mathcal{N}\coloneqq\{0,1,\dots\}=\mathbb{N}$.
Da es aber offensichtlich eine Bijektion zwischen $\mathbb{N}$ und $\mathbb{Q}$ gibt, lässt sich auch $\mathcal{N}\coloneqq\mathbb{Q}$ festlegen, wodurch sich die Vorteile einer dichten Ordnung\footnote{Eine dichte Ordnung ist eine lineare Ordnung so, dass zwischen je zwei Elementen ein drittes liegt.} im Vergleich zu $\PCTL$ ausnutzen lassen. \cite{alur1990model}

\begin{definition}[Zeitliche Graphen]
	Ein \textit{zeitlicher Graph} ist ein Tupel $\mathfrak{S}=(S,s_0,E,C,\pi,\tau,\mu)$ mit folgenden Definitionen \cite{alur1990model}:
	\begin{itemize}
		\item $S$ ist eine endliche Menge an Knoten.
		\item $s_0\in S$ ist der Startzustand.
		\item $E\subseteq S\times S$ ist die Kantenrelation.
		\item $C$ ist eine endliche Menge an Uhren.
		\item $\pi:E\to 2^C$ ist eine Abbildung, die jeder Kante eine Menge an Uhren zuweist.
		\item $\tau$ ist eine Abbildung, die jeder Kante eine Formel zuweist, die aus Booleschen Junktoren über den atomaren Formeln $x\leq c$ und $c\leq x$ besteht, wobei $c\in C$ und $x\in \mathcal{N}$ gilt.
		\item Für eine Menge an atomaren Aussagen $\mathsf{AP}$ ist $\mu:S\to 2^{\mathsf{AP}}$ eine Abbildung, die jedem Zustand eine Menge an atomaren Aussagen zuweist.
	\end{itemize}
	
	Ein zeitlicher Graph besitzt also eine Menge an sogenannten Uhren $C$.
	Diese zählen unabhängig voneinander hoch so, dass jede Uhr zu jedem \glqq Zeitpunkt\grqq{} einen reellen Wert $x\in \mathbb{R}_{\geq 0}$ speichert.
	Mithilfe von $\pi$ lassen sich Uhren zurücksetzen, für jede Transition lässt sich also eine Menge an Uhren auswählen, welche mit dem Wechsel über die Transition zurückgesetzt werden.
	Zusätzlich existiert für jede Kante eine Formel, welche bestimmte Voraussetzungen an die Transition stellt.
\end{definition}

Semantisch soll ein zeitlicher Graph so interpretiert werden, dass eine Kante $e\in E$ nur dann genommen werden kann, wenn $\tau(e)$ zum aktuellen Zeitpunkt erfüllt wird.
Alle Uhren zählen gleich schnell hoch, können aber natürlich unterschiedliche Werte besitzen, da das Zurücksetzen unabhängig voneinander passieren kann.

Um diese Definition besser zu verstehen, soll ein Beispiel angeführt werden.
\begin{example}[Beispiel für einen zeitlichen Graphen]
	Sei $\mathsf{AP}=\{\mathsf{running},\mathsf{stopped},\mathsf{warning},\mathsf{error}\}$ eine Menge an atomaren Aussagen und $\mathfrak{S}=(S,s_0,E,C,\pi,\tau,\mu)$ ein zeitlicher Graph mit
	\begin{itemize}
		\item $S\coloneqq \{s_0,s_1,s_2\}$
		\item $E\coloneqq\{(s_0,s_2),(s_1,s_0),(s_1,s_1),(s_1,s_2),(s_2,s_1)\}$
		\item $C\coloneqq\{x,y\}$
		\item $\pi(u,v) = \begin{cases}
			\{x\} & \text{falls } v = s_2 \\
			\{y\} & \text{falls } (u,v)=(s_1,s_0) \\
			\emptyset & \text{sonst} \end{cases}$
		\item $\tau(u,v) = \begin{cases}
			\top & \text{falls } v = s_2 \\
			x\geq 2 & \text{falls } u = s_2 \\
			x \geq 3 & \text{sonst}
		\end{cases}$
		\item $\mu(s)=\begin{cases}
			\{\mathsf{running}\} & \text{falls } s = s_0 \\
			\{\mathsf{stopped},\mathsf{warning}\} & \text{falls } s = s_1 \\
			\{\mathsf{stopped},\mathsf{error}\} & \text{falls } s = s_2
		\end{cases}$
	\end{itemize}
	Dann lässt sich die graphische Darstellung von $\mathfrak{S}$ in Abbildung \ref{ZeitlicherGraph1} sehen\footnote{Die Formel $\top$ wird als Platzhalter für eine beliebige Tautologie wie zum Beispiel $x \geq 2 \lor \neg(x\geq 2)$.}.
	
	Es lässt sich also sehen, dass die Uhr $x$ die zeit stoppt, die seit dem Letzten Fehler passiert ist, während die Uhr $y$ die Zeit misst, die seit der Letzten Wiederaufnahme des Betriebs des Systems vergangen ist.
	Weiter gibt $\tau$ uns die Information, dass wenn ein Fehler auftritt, für zwei Zeiteinheiten der Fehler bestehen bleiben muss und die darauf folgende Fehlermeldung für mindestens drei Zeiteinheiten seit dem auftreten des Fehlers beibehalten wird.
\end{example}

\begin{figure}[h]
	\begin{center}
		\begin{tikzpicture}[shorten >= 1pt, node distance=6cm, on grid]
			\node[state, initial left, initial text={}, align=center] (s_0) [] {$s_0$ \\ $\{\mathsf{running}\}$};
			\node[state, align=center] (s_1) [right=of s_0] {$s_1$ \\ $\{\mathsf{stopped},$\\$\mathsf{warning}\}$};
			\node[state, align=center] (s_2) [below=of s_1] {$s_2$ \\ $\{\mathsf{stopped},$\\$\mathsf{error}\}$};
			
			\path[-stealth]
			(s_0) edge [] node[align=center, left] {$\top$, \\ $\reset{x}$} (s_2)
			
			(s_1) edge [bend right] node[align=center, right] {$\top$, \\ $\reset{x}$} (s_2)
			(s_1) edge [] node[align=center, above] {$x\geq 3$ \\ $\reset{y}$} (s_0)
			
			(s_2) edge [bend right] node[align=center, right] {$x\geq 2$} (s_1)
			;
		\end{tikzpicture}
		
		\caption{Die graphische Darstellung des zeitlichen Graphen $\mathfrak{S}$}
		\label{ZeitlicherGraph1}
	\end{center}
\end{figure}

Um nun $\TCTL$ zu definieren benötigen wir noch einige Begriffe und Strukturen.
Für einen zeitlichen Graphen $\mathfrak{S}$ definiert $\Gamma(\mathfrak{S})$ die Menge aller möglichen Zuweisungen von Werten zu den Uhren, formal also $\Gamma(\mathfrak{S})\coloneqq \{\nu \, | \, \nu : C \to \mathbb{R}_{\geq 0}\}$.
Weiter schreiben wir für ein $\nu\in \Gamma(\mathfrak{S})$ und ein $t\in \mathbb{R}_{\geq 0}$, den Ausdruck $\nu+t$ für eine neue Zuweisung definiert als $(\nu+t)(x) \coloneqq \nu(x)+t$ und für ein $x\in C$ definieren wir die Schreibweise $[x\mapsto t]\nu$ als 
\[([x\mapsto t]\nu)(y)\coloneqq \begin{cases}
	t & \text{falls } x=y \\
	\nu(y) & \text{sonst}
\end{cases}\]
Eine interessante Beobachtung ist die, dass die eine Konfiguration eines zeitlichen Graphens ein Paar aus Zustand und Uhr-Belegungen sind.
Der aktuelle Stand eines zeitlichen Graphens $\mathfrak{S}$ lässt sich also eindeutig durch das Paar $\langle s,\nu \rangle$ charakterisieren, wobei $s$ ein Zustand ist und $\nu\in \Gamma(\mathfrak{S})$ gilt. \cite{alur1990model}

Damit können wir Läufe durch zeitliche Graphen definieren, welche stetige Zustandswechsel erlauben. 
Es ist also möglich nicht nur zu diskreten Zeitpunkten einen Zustand zu wechseln, wodurch die in der Einleitung benannten Vorteile von $\TCTL$ verwendet werden können.

\begin{definition}[$\langle s,\nu \rangle$-Lauf]
	Sei $\langle s,\nu \rangle$ eine Konfiguration des zeitlichen Graphen $\mathfrak{S}=(S,s_0,E,C,\pi,\tau,\mu)$. Dann ist ein $\langle s,\nu \rangle$-Lauf eine unendliche Folge an Tripeln der Form 
	$$(\langle s,\nu,0\rangle = \langle s_1,\nu_1,t_1\rangle,\langle s_2,\nu_2,t_2\rangle,\dots)\in (S\times \Gamma(\mathfrak{S})\times \mathbb{R}_{\geq 0})^\omega$$ 
	so, dass folgende Regeln eingehalten werden \cite{alur1990model}:
	\begin{enumerate}
		\item Für alle $i\in \mathbb{N}\setminus\{0\}$ gilt $t_{i+1}>t_i$. Die Zeit-Werte steigen also streng monoton.
		\item Für die Tripel $\langle s_i,\nu_i,t_i\rangle$ und $\langle s_{i+1},\nu_{i+1},t_{i+1}\rangle$ definieren wir $e_i=(s_i,s_{i+1})$ und es muss gelten $e_i\in E$.
		\item Für alle $i\in \mathbb{N}\setminus \{0\}$ gilt $\nu_{i+1}=[\pi(e_i)\mapsto 0](\nu_i+t_{i+1}-t)$.
		\item Für die boolesche Voraussetzung $\tau(e_i)$ ist $(\nu_i + t_{i+1}-t_i)$ eine erfüllende Belegung der Uhr-Werte.
		\item Für jedes $t\in \mathbb{R}_{\geq 0}$ gibt es ein $j$ so, dass $t_j\geq t$. Es gibt also keine obere Schranke für die Zeit-Werte.
	\end{enumerate}
\end{definition}

Nun können wir $\TCTL$ definieren.

\begin{definition}[Syntax von $\TCTL$]
	Sei $\mathsf{AP}$ eine Menge an atomaren Aussagen, $p\in \mathsf{AP}$ und $c\in \mathcal{N}$. Dann definieren die beiden folgenden Grammatiken die Logik $\TCTL$:
	\begin{align*}
		\varphi &\Coloneqq p \,|\, \varphi \land \varphi \,|\, \neg\varphi \,|\, \exists\varphi \operatorname{U}_{\kappa c}\varphi \,|\, \forall\varphi \operatorname{U}_{\kappa c}\varphi \\
		\kappa &\Coloneqq \, < \,|\, \leq \,|\, = \,|\, \geq \,|\, >
	\end{align*}
	Die Menge der $\TCTL$-Formeln sind die ausdrücke, die von $\varphi$ erzeugt werden. \cite{alur1990model}
\end{definition}

Informell soll $\exists\varphi_1 \operatorname{U}_{\sim c}\varphi_2$ bedeuten, dass es einen Präfix gibt, der $\kappa c$ Zeiteinheiten lang ist und in dem $\varphi_1$ gilt, wobei im Zustand nach dem Präfix $\varphi_2$ gelten muss.
Die Bedeutung von $\forall\varphi_1 \operatorname{U}_{\kappa c}\varphi_2$ ist analog.

Schließlich können wir die Semantik von $\TCTL$ definieren.
\begin{definition}[Semantik von $\TCTL$]
	Sei $\mathfrak{S}=(S,s_0,E,C,\pi,\tau,\mu)$ ein zeitlicher Graph.
	Dann können wir die Modellrelation $\models$ zwischen Konfigurationen von zeitlichen Graphen und $\TCTL$-Formeln induktiv definieren. Sei $s\in S$, $nu\in \Gamma(\mathfrak{S})$, $p\in \mathsf{AP}$, $c\in \mathcal{N}$ und $\sim\in \{<,\leq,=,\geq,>\}$. \cite{alur1990model}
	\begin{itemize}
		\item $\langle s,\nu\rangle \models p$ gdw. $p\in \mu(s)$
		\item $\langle s,\nu\rangle \models \varphi_1\land \varphi_2$ gdw. $s\models \varphi_1$ und $s\models \varphi_2$
		\item $\langle s,\nu \rangle \models \neg\varphi$ gdw. $s\not\models\varphi$
		\item $\langle s,\nu \rangle \models \exists\varphi_1 \operatorname{U}_{\sim c}\varphi_2$ gdw. es einen $\langle s,\nu\rangle$-Lauf gibt, mit $t_i \sim c$, $s_i\models \varphi_2$ und $s_j\models \varphi_1$ für $1\leq j < i$.
		\item $\langle s,\nu \rangle\models \forall\varphi_1 \operatorname{U}_{\sim c}\varphi_2$ gdw. für alle $\langle s,\nu\rangle$-Läufe gilt, dass es ein $i\in \mathbb{N}$ gibt, mit $t_i \sim c$, $s_i\models \varphi_2$ und für alle $1\leq j < i$ gilt $s_j\models \varphi_1$.
	\end{itemize}
\end{definition}

Damit können wir bestimmen, wann eine Konfiguration eine $\TCTL$-Formel erfüllt.
\begin{example}[Beispiel für das Auswerten von $\TCTL$-Formeln]
	Betrachte bspw. den zeitlichen Graphen aus Abbildung \ref{ZeitlicherGraph1} und die Formel 
	$$\varphi\coloneqq \exists\mathsf{stopped}\operatorname{U}_{< 3} \mathsf{running},$$ die besagt, dass das Systems stoppt und in weniger als drei Zeiteinheiten in einen laufenden Zustand wechselt.
	Sei $\nu$ eine zeitliche Belegung mit $\nu(x)=0$ und $\nu(y)\in \mathbb{R}_{\geq 0}$ beliebig.
	Dann stellt die Konfiguration $\alpha = \langle s_2,\nu \rangle$ dar, dass gerade in den Zustand $s_2$ gewechselt wurde, wodurch die Uhr $x$ zurückgesetzt wurde.
	Wenn wir nun $\alpha \models \varphi$ betrachten, dann fällt auf, dass der einzige Pfad zu einem Zustand mit $\mathsf{running}$ der Pfad $s_2, s_1,s_0$ ist. 
	Weiter ist die Transition $(s_1,s_0)$ erst möglich, wenn $x\geq 3$ gilt.
	Da wir unsere Auswertung mit $\nu_1(x)=0=t_1$ beginnen, ist $\nu_i(x)=t_i$ für alle $i\geq 1$.
	Daraus ergibt sich aber auch, dass für alle $\langle s,\nu \rangle$-Läufe gilt, dass wenn $s_i = s_0$ gilt, $\nu_i(x)=t_i \geq 3$ gelten muss.
	Es folgt also $\alpha \not\models \varphi$.
\end{example}

Wie man an diesem Beispiel erkennen konnte, ist das Auswerten von $\TCTL$-Formeln nicht trivial.
Aus diesem Grund ist die algorithmische Betrachtung des Model-Checking Spiels für $\TCTL$ äußerst interessant und wird in \cite{alur1990model} sehr konkret besprochen.
Da der vorgestellte Algorithmus aber um einiges komplexer ist, also die in Kapitel \ref{ChapMCAlgs} diskutierten, soll hier bloß die grobe Idee angemerkt werden.
Es lässt sich feststellen, dass im Kontext des Model-Checkings zwei Zeitbelegungen $\nu$ und $\nu'$ äquivalent sind ($\nu \cong \nu'$), wenn die abgerundeten Ganzzahlwerte und die Reihenfolge der Nachkomma-Werte gleich sind.

Formal verwenden wir $\lfloor x \rfloor$ für die größte ganze Zahl $y$ mit $y\leq x$ und $\operatorname{frac}(x)$ für $x-\lfloor x \rfloor$. Weiter sei für $x\in C$ der Wert $c_x\in \mathcal{N}$ definiert als $c_x\coloneqq \max\{c : c \leq x \text{ oder } x\leq c \text{ kommt in } \tau(e) \text{ vor}, e\in E \text{ bel.}\}$, also als größte Konstante, mit der $x$ verglichen wird.
Dann gilt für $\nu,\nu'\in \Gamma(\mathfrak{S})$, dass $\nu \cong \nu'$ genau dann, wenn
\begin{enumerate}
	\item für alle $x\in C$ gilt, dass entweder $\lfloor \nu(x)\rfloor = \lfloor \nu'(x)\rfloor$ oder dann $\nu(x)$ und $\nu'(x)$ größer als $c_x$ sind und
	\item für alle $x,y\in C$ mit $\nu(x)\leq c_x$ und $\nu(y)\leq c_y$ gilt, dass $\operatorname{fract}(\nu(x))\leq \operatorname{fract}(\nu(y))$ gdw. $\operatorname{fract}(\nu'(x))\leq \operatorname{fract}(\nu'(y))$. \cite{alur1990model}
\end{enumerate}

Damit lässt sich dann erkennen, dass für eine beliebige $\TCTL$-Formel $\varphi$ und zwei äquivalente $\nu,\nu'\in \Gamma(\mathfrak{S})$ gilt, dass $\langle s,\nu \rangle\models \varphi$ gdw. $\langle s,\nu'\rangle \models \varphi$. \cite{alur1990model}

Betrachtet man nun die Äquivalenzklassen $\{[\nu] : \nu\in \Gamma(\mathfrak{S})\}$ der soeben definierten Äquivalenzrelation erhält man Mengen an Konfigurationen $\langle s,[\nu]\rangle$, welche wir Regionen nennen.
Schlussendlich lässt sich der Model-Checking Algorithmus dann über Pfade dieser Regionen definieren. \cite{alur1990model}

Der daraus resultierende Model-Checking Algorithmus hat eine Komplexität von 
$$\mathcal{O}\left[c(\varphi)\cdot \vert\varphi\vert \cdot (|S|+|E|) \cdot |C|! \cdot \prod_{x\in C}c_x\right],$$ 
wobei $c(\varphi)$ die größte in $\varphi$ vorkommende Konstante ist.
Der Algorithmus wächst also linear in Formellänge als auch Graphengröße, aber wächst exponentiell mit der Anzahl an Uhren. \cite{alur1990model}

Dies stellt eine sehr viel höhere Komplexität dar, als die in Kapitel \ref{ChapMCAlgs} vorgestellten Algorithmen.
Zudem waren die $\PCTL$-Algorithmen nicht optimiert für $p\in \{0,1\}$, was hier ja aber der Fall ist.
Offensichtlich ist die Art, wie $\PCTL$ Zeit implementiert sehr viel schwächer als $\TCTL$s Implementation, jedoch ist diese Steigerung an Aussagekraft auch sehr klar in der Model-Checking Komplexität erkennbar.
Ein Ausweiten von $\TCTL$ bzw. zeitlichen Graphen auf Markov-Ketten würde zusätzliche Komplikationen hinzufügen.
So würde es bspw. nicht mehr nur ausreichen, $\mathcal{T}$ von einer Kante abhängig zu machen.
Da es in einem zeitlichen Graphen nicht möglich ist, Kanten zu verwenden, deren boolesche Formeln nicht erfüllt werden, würde die das Wahrscheinlichkeitsmaß in diesen Fällen $0$ sein müssen.
Demnach wäre es nötig, $\mathcal{T}$ von der Kante, dem ausgehenden Knoten und einem zeitlichen Parameter abhängig zu machen.

Die Aussagekraft von $\TCTL$ ist im Vergleich aber um einiges höher.
So lässt sich zum Beispiel Zeit genau so darstellen wie in $\PCTL$ indem eine Uhr $x$ verwendet wird, die bei jedem Zustandswechsel zurückgesetzt wird und indem wir $\tau(e)$ für alle $e$ neu definieren durch $\tau(e)\gets \tau(e) \land x\leq 1 \land 1\leq x$.
Dadurch würde jede Transition nur bei $x=1$ genommen werden, wodurch das Verhalten, wie es $\PCTL$ bei Markov-Ketten voraussetzt implementiert wird.
Offensichtlich lassen sich in $\TCTL$ aber auch weitere Verhalten darstellen.
So könnte man bspw. bei einem Wechsel in einen Zustand für die ersten fünf Zeiteinheiten eine Menge an Kanten erlauben, nach den ersten fünf aber eine andere.
In $\PCTL$ wäre solch ein Verhalten nicht möglich, für das modellieren von Systemen ist solch eine Eigenschaft aber äußerst hilfreich, da nach fünf Zeiteinheiten bspw. nur noch in verschiedene Fehlerzustände gewechselt werden könnte.

Es lässt sich also erkennen, dass $\PCTL$ trotz der, bzgl. Zeit, geringeren Aussagekraft auch Vorteile gegenüber $\TCTL$ bietet.
Falls es aber wichtig ist starke Aussagen über das zeitliche Verhalten eines Systems zu formulieren, wäre $\TCTL$ vermutlich die bessere Wahl.


\subsection{Erweiterung von $\CTL$ durch Wahrscheinlichkeiten}

Der \textit{modale $\mu$-Kalkül} ($\Lmu$) stellt eine sehr wichtige Fixpunktlogik für Korrektheitsverifikation dar.
Das liegt daran, dass es möglich ist, die meisten für Model-Checking verwendeten Logiken in diese einzubetten. So lässt sich beispielsweise zu jeder $\CTL$- oder $\CTL^*$-Formel eine äquivalente $\Lmu$-Formel definieren.
Zusätzlich lassen sich aber auch noch weitere Aussagen treffen, wie bspw. dass auf einem Pfad in jedem zweiten Zustand eine Bedingung gilt.
Dies lässt sich weder in $\CTL$, noch $\CTL^*$ ausdrücken. \cite{cleaveland2005probabilistic}

Zu Beginn soll die Syntax und Semantik kurz definiert werden, für mehr Informationen wird dabei aber auf \cite{stirling1991local} und \cite{kozen1983results} verwiesen.
\begin{definition}[Syntax und Semantik von $\Lmu$]
	Die Menge der $\Lmu$-Formeln wird für Variablen $X$, atomare Aussagen $a$ und Aktionen $\alpha$ durch die folgende Grammatik definiert:
	$$
	\varphi \Coloneqq X \,|\, a \,|\, \neg a \,|\, \varphi \land \varphi \,|\, \varphi \lor \varphi \,|\, \langle \alpha\rangle \varphi \,|\, [\alpha]\varphi \,|\, \mu X.\varphi \,|\, \nu X.\varphi
	$$
	Variablen werden, wie aus $\FO$ bekannt, durch die Operatoren $\nu$ und $\mu$ gebunden und sind sonst frei.
	Der Einfachheit halber sind freie Variablen im Weiteren nicht erlaubt.
	
	Für den modalen $\mu$-Kalkül benötigen wir eine etwas abgeänderte Art an Transitionssystem.
	Sei $\mathsf{Act}$ eine Menge an Aktionen, $S$ eine Menge an Zuständen und $\mathsf{AP}$ eine Menge an atomaren Aussagen.
	Dann ist $\mathcal{K}=(S,(E_\alpha)_{\alpha\in \mathsf{Act}}, \mathcal{L}:S\to 2^{\mathsf{AP}})$ ein wie vorher definiertes Transitionssystem mit dem Unterschied, dass für jedes $\alpha\in \mathsf{Act}$ eine einzelne Kantenrelation existiert.
	Damit können wir die Semantik von $\Lmu$-Formeln als Modellbeziehung zwischen Zuständen $s\in S$ und Formeln induktiv definieren:
	\begin{itemize}
		\item $s\models a$ gdw. $a\in \mathcal{L}(s)$
		\item $s\models \neg a$ gdw. $a\notin \mathcal{L}(s)$
		\item $s\models \varphi_1\land\varphi_2$ gdw. $s\models \varphi_1$ und $s\models \varphi_2$
		\item $s\models \varphi_1\lor\varphi_1$ gdw. $s\models \varphi_1$ oder $s\models \varphi_2$
		\item $s\models \langle \alpha \rangle\varphi$ gdw. es ein $s'\in S$ mit $(s,s')\in E_\alpha$ gibt so, dass $s'\models \varphi$
		\item $s\models [\alpha]\varphi$ gdw. für alle $s'\in S$ mit $(s,s')\in E_\alpha$, $s'\models \varphi$ gilt
		\item $s\models \mu X.\varphi$ gdw. $s\in \operatorname{lfp}(F_\varphi)$
		\item $s\models \nu X.\varphi$ gdw. $s\in \operatorname{gfp}(F_\varphi)$
	\end{itemize}
\end{definition}

Es lässt sich also ein ähnlicher Prozess wie bei $\PCTL$ erkennen.
Für eine qualitative Logik, welche bloß aussagen kann, ob ein Zustand eine Spezifikation erfüllt, wird eine quantitative Erweiterung definiert, die genauere Aussagen über das spezifische Verhalten treffen kann.
Bevor dies für $\Lmu$ aber passieren kann, werden noch einige Vorschritte benötigt.
\begin{definition}[Reaktive-probabilistische-Transitionssysteme]
	Sei $S$ eine abzählbare Menge an Zuständen, $\mathsf{Act}$ eine Menge an Aktionen und $\mathsf{AP}$ eine Menge an atomaren Aussagen.
	Dann bezeichnen wir ein Tupel $\mathfrak{S}=(S,\delta,P,\mathcal{L})$ als ein \textit{reaktives-probabilistisches-Transitionssystem} (RPLTS), wenn $\delta\subseteq S\times \mathsf{Act} \times S$ eine Übergangsrelation, $P:\delta\to (0,1]$ eine Transitions-Wahrscheinlichkeitsfunktion und $\mathcal{L}:S\to2^{\mathsf{AP}}$ eine Bezeichnungsfunktion ist.
	Weiter muss für $P$ gelten, dass
	\begin{enumerate}
		\item Für alle $s\in S$ und alle $\alpha\in \mathsf{Act}$ gilt $\sum_{s' : (s,a,s')\in \delta} P(s,a,s')\in \{0,1\}$
		\item Für alle $s\in S$ und alle $\alpha\in \mathsf{Act}$ gilt, wenn es ein $s'$ mit $(s,a,s')\in \delta$ gibt, dann ist $\sum_{s' : (s,a,s')\in \delta} P(s,a,s') = 1$ \cite{stirling1991local}
	\end{enumerate}
\end{definition}

Nun können wir Berechnungen von RPLTS als Abfolge von Zuständen der Form $\sigma = s_0\xrightarrow{a_1}s_1 \dots $

% Es gibt auch Logiken die nur Wahrscheinlichkeiten hinzufügen. Lassen sich unterschiedliche Ansätze finden? Lösen diese andere Probleme? Paper mit anderen probabilistischen Logiken (die $\CTL$ erweitern): \cite{hart1984probabilistic}, \cite{lehmann1982reasoning} und \cite{christoff1992reasoning}.












